// proto/cyberday.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/cyberday.proto

package cyberday

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RegistroEntidades_RegistrarEntidad_FullMethodName = "/cyberday.RegistroEntidades/RegistrarEntidad"
)

// RegistroEntidadesClient is the client API for RegistroEntidades service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegistroEntidadesClient interface {
	RegistrarEntidad(ctx context.Context, in *SolicitudRegistro, opts ...grpc.CallOption) (*RespuestaRegistro, error)
}

type registroEntidadesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegistroEntidadesClient(cc grpc.ClientConnInterface) RegistroEntidadesClient {
	return &registroEntidadesClient{cc}
}

func (c *registroEntidadesClient) RegistrarEntidad(ctx context.Context, in *SolicitudRegistro, opts ...grpc.CallOption) (*RespuestaRegistro, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaRegistro)
	err := c.cc.Invoke(ctx, RegistroEntidades_RegistrarEntidad_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegistroEntidadesServer is the server API for RegistroEntidades service.
// All implementations must embed UnimplementedRegistroEntidadesServer
// for forward compatibility.
type RegistroEntidadesServer interface {
	RegistrarEntidad(context.Context, *SolicitudRegistro) (*RespuestaRegistro, error)
	mustEmbedUnimplementedRegistroEntidadesServer()
}

// UnimplementedRegistroEntidadesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRegistroEntidadesServer struct{}

func (UnimplementedRegistroEntidadesServer) RegistrarEntidad(context.Context, *SolicitudRegistro) (*RespuestaRegistro, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistrarEntidad not implemented")
}
func (UnimplementedRegistroEntidadesServer) mustEmbedUnimplementedRegistroEntidadesServer() {}
func (UnimplementedRegistroEntidadesServer) testEmbeddedByValue()                           {}

// UnsafeRegistroEntidadesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegistroEntidadesServer will
// result in compilation errors.
type UnsafeRegistroEntidadesServer interface {
	mustEmbedUnimplementedRegistroEntidadesServer()
}

func RegisterRegistroEntidadesServer(s grpc.ServiceRegistrar, srv RegistroEntidadesServer) {
	// If the following call pancis, it indicates UnimplementedRegistroEntidadesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RegistroEntidades_ServiceDesc, srv)
}

func _RegistroEntidades_RegistrarEntidad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolicitudRegistro)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistroEntidadesServer).RegistrarEntidad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegistroEntidades_RegistrarEntidad_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistroEntidadesServer).RegistrarEntidad(ctx, req.(*SolicitudRegistro))
	}
	return interceptor(ctx, in, info, handler)
}

// RegistroEntidades_ServiceDesc is the grpc.ServiceDesc for RegistroEntidades service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegistroEntidades_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.RegistroEntidades",
	HandlerType: (*RegistroEntidadesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegistrarEntidad",
			Handler:    _RegistroEntidades_RegistrarEntidad_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	ConfirmarInicio_Confirmacion_FullMethodName = "/cyberday.ConfirmarInicio/Confirmacion"
)

// ConfirmarInicioClient is the client API for ConfirmarInicio service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfirmarInicioClient interface {
	Confirmacion(ctx context.Context, in *SolicitudInicio, opts ...grpc.CallOption) (*RespuestaInicio, error)
}

type confirmarInicioClient struct {
	cc grpc.ClientConnInterface
}

func NewConfirmarInicioClient(cc grpc.ClientConnInterface) ConfirmarInicioClient {
	return &confirmarInicioClient{cc}
}

func (c *confirmarInicioClient) Confirmacion(ctx context.Context, in *SolicitudInicio, opts ...grpc.CallOption) (*RespuestaInicio, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaInicio)
	err := c.cc.Invoke(ctx, ConfirmarInicio_Confirmacion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfirmarInicioServer is the server API for ConfirmarInicio service.
// All implementations must embed UnimplementedConfirmarInicioServer
// for forward compatibility.
type ConfirmarInicioServer interface {
	Confirmacion(context.Context, *SolicitudInicio) (*RespuestaInicio, error)
	mustEmbedUnimplementedConfirmarInicioServer()
}

// UnimplementedConfirmarInicioServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfirmarInicioServer struct{}

func (UnimplementedConfirmarInicioServer) Confirmacion(context.Context, *SolicitudInicio) (*RespuestaInicio, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Confirmacion not implemented")
}
func (UnimplementedConfirmarInicioServer) mustEmbedUnimplementedConfirmarInicioServer() {}
func (UnimplementedConfirmarInicioServer) testEmbeddedByValue()                         {}

// UnsafeConfirmarInicioServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfirmarInicioServer will
// result in compilation errors.
type UnsafeConfirmarInicioServer interface {
	mustEmbedUnimplementedConfirmarInicioServer()
}

func RegisterConfirmarInicioServer(s grpc.ServiceRegistrar, srv ConfirmarInicioServer) {
	// If the following call pancis, it indicates UnimplementedConfirmarInicioServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfirmarInicio_ServiceDesc, srv)
}

func _ConfirmarInicio_Confirmacion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolicitudInicio)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfirmarInicioServer).Confirmacion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfirmarInicio_Confirmacion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfirmarInicioServer).Confirmacion(ctx, req.(*SolicitudInicio))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfirmarInicio_ServiceDesc is the grpc.ServiceDesc for ConfirmarInicio service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfirmarInicio_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.ConfirmarInicio",
	HandlerType: (*ConfirmarInicioServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Confirmacion",
			Handler:    _ConfirmarInicio_Confirmacion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	Ofertas_EnviarOferta_FullMethodName = "/cyberday.Ofertas/EnviarOferta"
)

// OfertasClient is the client API for Ofertas service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OfertasClient interface {
	EnviarOferta(ctx context.Context, in *Oferta, opts ...grpc.CallOption) (*RespuestaOferta, error)
}

type ofertasClient struct {
	cc grpc.ClientConnInterface
}

func NewOfertasClient(cc grpc.ClientConnInterface) OfertasClient {
	return &ofertasClient{cc}
}

func (c *ofertasClient) EnviarOferta(ctx context.Context, in *Oferta, opts ...grpc.CallOption) (*RespuestaOferta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaOferta)
	err := c.cc.Invoke(ctx, Ofertas_EnviarOferta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OfertasServer is the server API for Ofertas service.
// All implementations must embed UnimplementedOfertasServer
// for forward compatibility.
type OfertasServer interface {
	EnviarOferta(context.Context, *Oferta) (*RespuestaOferta, error)
	mustEmbedUnimplementedOfertasServer()
}

// UnimplementedOfertasServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOfertasServer struct{}

func (UnimplementedOfertasServer) EnviarOferta(context.Context, *Oferta) (*RespuestaOferta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnviarOferta not implemented")
}
func (UnimplementedOfertasServer) mustEmbedUnimplementedOfertasServer() {}
func (UnimplementedOfertasServer) testEmbeddedByValue()                 {}

// UnsafeOfertasServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OfertasServer will
// result in compilation errors.
type UnsafeOfertasServer interface {
	mustEmbedUnimplementedOfertasServer()
}

func RegisterOfertasServer(s grpc.ServiceRegistrar, srv OfertasServer) {
	// If the following call pancis, it indicates UnimplementedOfertasServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Ofertas_ServiceDesc, srv)
}

func _Ofertas_EnviarOferta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Oferta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OfertasServer).EnviarOferta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ofertas_EnviarOferta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OfertasServer).EnviarOferta(ctx, req.(*Oferta))
	}
	return interceptor(ctx, in, info, handler)
}

// Ofertas_ServiceDesc is the grpc.ServiceDesc for Ofertas service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Ofertas_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.Ofertas",
	HandlerType: (*OfertasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnviarOferta",
			Handler:    _Ofertas_EnviarOferta_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	NodoDB_AlmacenarOferta_FullMethodName     = "/cyberday.NodoDB/AlmacenarOferta"
	NodoDB_GetHistorialOfertas_FullMethodName = "/cyberday.NodoDB/GetHistorialOfertas"
)

// NodoDBClient is the client API for NodoDB service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodoDBClient interface {
	AlmacenarOferta(ctx context.Context, in *Oferta, opts ...grpc.CallOption) (*RespuestaAlmacenarOferta, error)
	GetHistorialOfertas(ctx context.Context, in *SolicitudHistorialBD, opts ...grpc.CallOption) (*RespuestaHistorialBD, error)
}

type nodoDBClient struct {
	cc grpc.ClientConnInterface
}

func NewNodoDBClient(cc grpc.ClientConnInterface) NodoDBClient {
	return &nodoDBClient{cc}
}

func (c *nodoDBClient) AlmacenarOferta(ctx context.Context, in *Oferta, opts ...grpc.CallOption) (*RespuestaAlmacenarOferta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaAlmacenarOferta)
	err := c.cc.Invoke(ctx, NodoDB_AlmacenarOferta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodoDBClient) GetHistorialOfertas(ctx context.Context, in *SolicitudHistorialBD, opts ...grpc.CallOption) (*RespuestaHistorialBD, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaHistorialBD)
	err := c.cc.Invoke(ctx, NodoDB_GetHistorialOfertas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodoDBServer is the server API for NodoDB service.
// All implementations must embed UnimplementedNodoDBServer
// for forward compatibility.
type NodoDBServer interface {
	AlmacenarOferta(context.Context, *Oferta) (*RespuestaAlmacenarOferta, error)
	GetHistorialOfertas(context.Context, *SolicitudHistorialBD) (*RespuestaHistorialBD, error)
	mustEmbedUnimplementedNodoDBServer()
}

// UnimplementedNodoDBServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodoDBServer struct{}

func (UnimplementedNodoDBServer) AlmacenarOferta(context.Context, *Oferta) (*RespuestaAlmacenarOferta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlmacenarOferta not implemented")
}
func (UnimplementedNodoDBServer) GetHistorialOfertas(context.Context, *SolicitudHistorialBD) (*RespuestaHistorialBD, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistorialOfertas not implemented")
}
func (UnimplementedNodoDBServer) mustEmbedUnimplementedNodoDBServer() {}
func (UnimplementedNodoDBServer) testEmbeddedByValue()                {}

// UnsafeNodoDBServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodoDBServer will
// result in compilation errors.
type UnsafeNodoDBServer interface {
	mustEmbedUnimplementedNodoDBServer()
}

func RegisterNodoDBServer(s grpc.ServiceRegistrar, srv NodoDBServer) {
	// If the following call pancis, it indicates UnimplementedNodoDBServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodoDB_ServiceDesc, srv)
}

func _NodoDB_AlmacenarOferta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Oferta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodoDBServer).AlmacenarOferta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodoDB_AlmacenarOferta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodoDBServer).AlmacenarOferta(ctx, req.(*Oferta))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodoDB_GetHistorialOfertas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolicitudHistorialBD)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodoDBServer).GetHistorialOfertas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodoDB_GetHistorialOfertas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodoDBServer).GetHistorialOfertas(ctx, req.(*SolicitudHistorialBD))
	}
	return interceptor(ctx, in, info, handler)
}

// NodoDB_ServiceDesc is the grpc.ServiceDesc for NodoDB service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodoDB_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.NodoDB",
	HandlerType: (*NodoDBServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AlmacenarOferta",
			Handler:    _NodoDB_AlmacenarOferta_Handler,
		},
		{
			MethodName: "GetHistorialOfertas",
			Handler:    _NodoDB_GetHistorialOfertas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	Consumer_RecibirOferta_FullMethodName = "/cyberday.Consumer/RecibirOferta"
)

// ConsumerClient is the client API for Consumer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsumerClient interface {
	RecibirOferta(ctx context.Context, in *Oferta, opts ...grpc.CallOption) (*RespuestaConsumidor, error)
}

type consumerClient struct {
	cc grpc.ClientConnInterface
}

func NewConsumerClient(cc grpc.ClientConnInterface) ConsumerClient {
	return &consumerClient{cc}
}

func (c *consumerClient) RecibirOferta(ctx context.Context, in *Oferta, opts ...grpc.CallOption) (*RespuestaConsumidor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaConsumidor)
	err := c.cc.Invoke(ctx, Consumer_RecibirOferta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsumerServer is the server API for Consumer service.
// All implementations must embed UnimplementedConsumerServer
// for forward compatibility.
type ConsumerServer interface {
	RecibirOferta(context.Context, *Oferta) (*RespuestaConsumidor, error)
	mustEmbedUnimplementedConsumerServer()
}

// UnimplementedConsumerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConsumerServer struct{}

func (UnimplementedConsumerServer) RecibirOferta(context.Context, *Oferta) (*RespuestaConsumidor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecibirOferta not implemented")
}
func (UnimplementedConsumerServer) mustEmbedUnimplementedConsumerServer() {}
func (UnimplementedConsumerServer) testEmbeddedByValue()                  {}

// UnsafeConsumerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsumerServer will
// result in compilation errors.
type UnsafeConsumerServer interface {
	mustEmbedUnimplementedConsumerServer()
}

func RegisterConsumerServer(s grpc.ServiceRegistrar, srv ConsumerServer) {
	// If the following call pancis, it indicates UnimplementedConsumerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Consumer_ServiceDesc, srv)
}

func _Consumer_RecibirOferta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Oferta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerServer).RecibirOferta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Consumer_RecibirOferta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerServer).RecibirOferta(ctx, req.(*Oferta))
	}
	return interceptor(ctx, in, info, handler)
}

// Consumer_ServiceDesc is the grpc.ServiceDesc for Consumer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Consumer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.Consumer",
	HandlerType: (*ConsumerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecibirOferta",
			Handler:    _Consumer_RecibirOferta_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	Finalizacion_InformarFinalizacion_FullMethodName = "/cyberday.Finalizacion/InformarFinalizacion"
)

// FinalizacionClient is the client API for Finalizacion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FinalizacionClient interface {
	InformarFinalizacion(ctx context.Context, in *NotificarFin, opts ...grpc.CallOption) (*ConfirmacionFin, error)
}

type finalizacionClient struct {
	cc grpc.ClientConnInterface
}

func NewFinalizacionClient(cc grpc.ClientConnInterface) FinalizacionClient {
	return &finalizacionClient{cc}
}

func (c *finalizacionClient) InformarFinalizacion(ctx context.Context, in *NotificarFin, opts ...grpc.CallOption) (*ConfirmacionFin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfirmacionFin)
	err := c.cc.Invoke(ctx, Finalizacion_InformarFinalizacion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinalizacionServer is the server API for Finalizacion service.
// All implementations must embed UnimplementedFinalizacionServer
// for forward compatibility.
type FinalizacionServer interface {
	InformarFinalizacion(context.Context, *NotificarFin) (*ConfirmacionFin, error)
	mustEmbedUnimplementedFinalizacionServer()
}

// UnimplementedFinalizacionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFinalizacionServer struct{}

func (UnimplementedFinalizacionServer) InformarFinalizacion(context.Context, *NotificarFin) (*ConfirmacionFin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InformarFinalizacion not implemented")
}
func (UnimplementedFinalizacionServer) mustEmbedUnimplementedFinalizacionServer() {}
func (UnimplementedFinalizacionServer) testEmbeddedByValue()                      {}

// UnsafeFinalizacionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FinalizacionServer will
// result in compilation errors.
type UnsafeFinalizacionServer interface {
	mustEmbedUnimplementedFinalizacionServer()
}

func RegisterFinalizacionServer(s grpc.ServiceRegistrar, srv FinalizacionServer) {
	// If the following call pancis, it indicates UnimplementedFinalizacionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Finalizacion_ServiceDesc, srv)
}

func _Finalizacion_InformarFinalizacion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificarFin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinalizacionServer).InformarFinalizacion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Finalizacion_InformarFinalizacion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinalizacionServer).InformarFinalizacion(ctx, req.(*NotificarFin))
	}
	return interceptor(ctx, in, info, handler)
}

// Finalizacion_ServiceDesc is the grpc.ServiceDesc for Finalizacion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Finalizacion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.Finalizacion",
	HandlerType: (*FinalizacionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InformarFinalizacion",
			Handler:    _Finalizacion_InformarFinalizacion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	Recovery_GetHistorialFiltrado_FullMethodName = "/cyberday.Recovery/GetHistorialFiltrado"
)

// RecoveryClient is the client API for Recovery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RecoveryClient interface {
	GetHistorialFiltrado(ctx context.Context, in *SolicitudHistorialConsumer, opts ...grpc.CallOption) (*RespuestaHistorialConsumer, error)
}

type recoveryClient struct {
	cc grpc.ClientConnInterface
}

func NewRecoveryClient(cc grpc.ClientConnInterface) RecoveryClient {
	return &recoveryClient{cc}
}

func (c *recoveryClient) GetHistorialFiltrado(ctx context.Context, in *SolicitudHistorialConsumer, opts ...grpc.CallOption) (*RespuestaHistorialConsumer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespuestaHistorialConsumer)
	err := c.cc.Invoke(ctx, Recovery_GetHistorialFiltrado_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RecoveryServer is the server API for Recovery service.
// All implementations must embed UnimplementedRecoveryServer
// for forward compatibility.
type RecoveryServer interface {
	GetHistorialFiltrado(context.Context, *SolicitudHistorialConsumer) (*RespuestaHistorialConsumer, error)
	mustEmbedUnimplementedRecoveryServer()
}

// UnimplementedRecoveryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRecoveryServer struct{}

func (UnimplementedRecoveryServer) GetHistorialFiltrado(context.Context, *SolicitudHistorialConsumer) (*RespuestaHistorialConsumer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistorialFiltrado not implemented")
}
func (UnimplementedRecoveryServer) mustEmbedUnimplementedRecoveryServer() {}
func (UnimplementedRecoveryServer) testEmbeddedByValue()                  {}

// UnsafeRecoveryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RecoveryServer will
// result in compilation errors.
type UnsafeRecoveryServer interface {
	mustEmbedUnimplementedRecoveryServer()
}

func RegisterRecoveryServer(s grpc.ServiceRegistrar, srv RecoveryServer) {
	// If the following call pancis, it indicates UnimplementedRecoveryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Recovery_ServiceDesc, srv)
}

func _Recovery_GetHistorialFiltrado_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolicitudHistorialConsumer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecoveryServer).GetHistorialFiltrado(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Recovery_GetHistorialFiltrado_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecoveryServer).GetHistorialFiltrado(ctx, req.(*SolicitudHistorialConsumer))
	}
	return interceptor(ctx, in, info, handler)
}

// Recovery_ServiceDesc is the grpc.ServiceDesc for Recovery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Recovery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.Recovery",
	HandlerType: (*RecoveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHistorialFiltrado",
			Handler:    _Recovery_GetHistorialFiltrado_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}

const (
	Caida_InformarCaida_FullMethodName = "/cyberday.Caida/InformarCaida"
)

// CaidaClient is the client API for Caida service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CaidaClient interface {
	InformarCaida(ctx context.Context, in *FailNotify, opts ...grpc.CallOption) (*FailACK, error)
}

type caidaClient struct {
	cc grpc.ClientConnInterface
}

func NewCaidaClient(cc grpc.ClientConnInterface) CaidaClient {
	return &caidaClient{cc}
}

func (c *caidaClient) InformarCaida(ctx context.Context, in *FailNotify, opts ...grpc.CallOption) (*FailACK, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailACK)
	err := c.cc.Invoke(ctx, Caida_InformarCaida_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CaidaServer is the server API for Caida service.
// All implementations must embed UnimplementedCaidaServer
// for forward compatibility.
type CaidaServer interface {
	InformarCaida(context.Context, *FailNotify) (*FailACK, error)
	mustEmbedUnimplementedCaidaServer()
}

// UnimplementedCaidaServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCaidaServer struct{}

func (UnimplementedCaidaServer) InformarCaida(context.Context, *FailNotify) (*FailACK, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InformarCaida not implemented")
}
func (UnimplementedCaidaServer) mustEmbedUnimplementedCaidaServer() {}
func (UnimplementedCaidaServer) testEmbeddedByValue()               {}

// UnsafeCaidaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CaidaServer will
// result in compilation errors.
type UnsafeCaidaServer interface {
	mustEmbedUnimplementedCaidaServer()
}

func RegisterCaidaServer(s grpc.ServiceRegistrar, srv CaidaServer) {
	// If the following call pancis, it indicates UnimplementedCaidaServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Caida_ServiceDesc, srv)
}

func _Caida_InformarCaida_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailNotify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CaidaServer).InformarCaida(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Caida_InformarCaida_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CaidaServer).InformarCaida(ctx, req.(*FailNotify))
	}
	return interceptor(ctx, in, info, handler)
}

// Caida_ServiceDesc is the grpc.ServiceDesc for Caida service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Caida_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cyberday.Caida",
	HandlerType: (*CaidaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InformarCaida",
			Handler:    _Caida_InformarCaida_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cyberday.proto",
}
